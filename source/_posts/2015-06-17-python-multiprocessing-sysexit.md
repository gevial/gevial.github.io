---
title: multiprocessing.Process и sys.exit()
tags: [python]
---
Мониторинг времени отклика серверов хостинга мы мониторим так.

Есть скрипт, который берёт список серверов и запрашивает с каждого веб-страничку (Wordpress с плагином Query Monitor), парсит оттуда время генерации страницы и время работы БД, по пути считает время скачивания странички со всей статикой.
Сначала опрос происходил последовательно в цикле, но это не есть путь самурая, поэтому решено было распараллелить процесс.
Сперва взгляд лёг на модуль threading. Однако я тогда ещё не ощутил на практике недостатки GIL (Global Interpreter Lock). Дело обернулось тем, что для каждого сервера время скачивания было 6-7 секунд, хотя настоящее значение лежит в пределах секунды. Так произошло как раз из-за GIL: таймеры в потоках были запущены, но фактически выполнялся лишь один поток, остальные продолжали ждать.

Тогда я решил поменять threading на multiprocessing, благо у них очень похожая семантика объектов.
Я вынес рабочий код из подкласса `threading.Thread` в функцию (не стал делать подкласс `multiprocessing.Process`, так как захотелось использовать пул подпроцессов - `multiprocessing.Pool`, а он не поддерживает создание чайлдов из кастомных классов), функция в зависимости от статуса исполнения завершалась `sys.exit(0)` или `sys.exit(1)`. Но мой код не заработал.

Проблема заключалась в том, что, после обработки всех серверов, скрипт и его дочерние процесы продолжали работать. `strace` показал, что они висят в ожидании мьютекса. По всей видимости, `multiprocessing.Process` оборачивает полезный код, передаваемый в виде функции, дополнительными вызовами, в частности, отпускает мьютекс. В моей функции был вызов `sys.exit()`, поэтому этот код никогда не вызывался. Это лишь предположение, но факт оказался фактом: когда я поменял `sys.exit()` на `return`, скрипт и его подпроцессы успешно завершались.

Вывод: не используйте `sys.exit()` в функции, передаваемой в качестве `target` экземпляру `multiprocessing.Process`.
